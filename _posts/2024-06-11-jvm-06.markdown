---
layout: post
title: "JVM 시리즈 - 신세대 가비지 컬렉터의 종류"
date: 2024-06-11 21:26:01 +0900
categories: [ Java, JVM ]
---

# 신세대 가비지 컬렉터 정리

신세대 가비지 컬렉터라 할 수 있는 ZGC 와 셰넌도어에 대해서 정리해보겠다. 가비지 컬렉터를 측정하는 가장 중요한 지표는 3가지이다.

1. 지연 시간
2. 처리량
3. 메모리 사용량

이 3가지를 모두 충족하는 완벽한 컬렉터는 없으며, 일반적으로 좋은 컬렉터는 3가지 중 2가지의 기준을 충족할 것이다. 요즘에는 이 3가지 중 지연 시간의 중요성이 점점 커지고
있다. 하드웨어의 성능 향상으로 처리량과 메모리 사용량은 감당할 수 있기 때문이다.

## 셰년도어

레드햇이 독립적으로 시작한 프로젝트로, OpenJDK 에 기증됐다. 가비지 컬렉션으로 인한 일시 정지를 10 밀리초 이내로 묶는 것이 셰넌도어의 목표다.

### 개선 사항

G1 과 유사하게 작동한다. 힙을 리전들로 쪼개 처리하고, 큰 객처 전용의 거대 리전을 지원한다. 셰넌도어의 동작 방식은 다음과 같다.

1. 최초 표시 : GC 루트에서 직접 참조하는 객체를 표시한다.
2. 동시 표시 : 객체 그래프를 타고 힙을 탐색하며 도달 가능한 모든 객체를 표시한다.
3. 최종 표시 : 보류 중인 모든 표시를 완료하고, GC 루트 집합을 다시 스캔한다.
4. 동시 청소 : 살아 있는 객체가 하나도 없는 리전을 청소한다.
5. 동시 이주 : **(핵심)** 사용자 스레드를 멈추지 않고 회수 집합 안에 살아 있는 객체를 다른 빈 리전으로 복사한다. 이동 후, 참조 주소를 수정하기 위해서 읽기 장벽과 포워딩 포인터를 사용한다.
6. 최초 참조 갱신 : 힙에서 옛 객체를 가리키는 모든 참조를 새로운 주소로 수정한다. stop the world 가 발생한다.
7. 동시 참조 갱신 : 참조 갱신을 실제로 시작한다.
8. 최종 참조 갱신 : 힙의 참조를 모두 갱신한 후, GC 루트 집합의 참조를 갱신한다. stop the world 가 발생한다.
9. 동시 청소 : 회수 집합의 모든 리전에는 살아 있는 객체가 없기에 다시 청소를 수행한다.

### 동시 이주 - 포워딩 포인터

개념을 소개한 사람의 이름을 따 브룩스 포인터라고도 한다. 기존 방법은 사용자가 옛 객체가 저장된 메모리에 접근하는 순간, 해당 부분에 설치한 트랩이 발생하여 예외 처리기를 실행시키고, 처리기에서 새로운 객체를 사용하게 하는 것이다. 이 방법은 사용자 모드와 커널 모드를 전환해야 하기에 비용이 크다.
<br><span> 포워딩 포인터 방식은, 객체 레이아웃 구조 상단에 참조 필드를 하나 추가하는 방식이다. 이주가 아닌 경우에는 객체 자신을 가리키고, 이주인 경우에는 새로운 객체를 가리키게 하는 것이다. 포인터만큼 오버헤드가 모든 객체에 더해지지만, 방식이 간단하다.
<br><span> 포인터를 새로 갱신하는 경우, 스레드간 경쟁이 일어날 수 있다. 따라서 포워딩 포인터에 대한 스레드 접근은 동기적이어야 한다. 이는 낙관락 방식을 사용하여 해결했다.
<br><span> JDK 13 에서는 포워딩 포인터를 객체 헤더에 아에 통합했다. 객체 헤더의 마지막 2비트를 락 플래그로 사용하는 방법이다. 이로 인해서 셰넌도어는 다른 가비지 컬렉터보다 메모리를 5-10% 더 사용하지만, 가지비 컬렉션의 성능 자체는 10-15% 높은 성능을 보인다.

### 실전 성능

![Desktop View](/assets/img/2024-06-11/2024-06-11-gc-benchmark.png){: width="972" height="589" }
<br>
출처: [lonut Balosin](https://ionutbalosin.com/2019/12/jvm-garbage-collectors-benchmarks-report-19-12/)

일시 정지 시간에 있어서는 다른 GC 보다 우위를 보인다.
